# Lerne selber Informatik

Als autodidaktische/r Ingenieur/in oder Bootcamp Absolvent/in schuldest du es dir selber, Informatik zu lernen. Zum GlÃ¼ck kannst du dir eine erstklassige Informatikausbildung verschaffen, ohne Jahre und ein kleines VermÃ¶gen in ein Studium zu investieren ðŸ’¸.

Es gibt da drauÃŸen zahlreiche Ressourcen, manche davon besser als andere. Du brauchst jedoch nicht nochmal eine Liste von "200+ kostenlosen Online-Kursen". Du brauchst die Antwort auf folgende Fragen:

* **Welche Themen** soll ich lernen, und warum?
* Was ist die **beste LektÃ¼re oder Vorlesungsreihe** fÃ¼r jedes Thema?

Dieser Leitfaden versucht, diese Fragen endgÃ¼ltig zu beantworten.

## TL;DR (Zusammenfassung)

Lerne alle neun unten aufgefÃ¼hrten Themen etwa in der gegebenen Reihenfolge mithilfe des Lehrbuchs oder Videovorlesungen, idealerweise jedoch mit beiden. Rechne etwa 100-200 Lernstunden pro Thema ein, und besuche nochmal deine Favoriten im Laufe deiner Karriere ðŸš€.

| Thema                                                                   | Weshalb lernen?                                                                                                                                                              | Buch                                                          | Videovorlesung                      |
| --------------                                                          | ---------------                                                                                                                                                              | ----                                                          | --------------                      |
| **[Programmierung](#programmierung)**                                   | Sei nicht die Person, die etwas wie Rekursion "nie ganz verstanden" hat.                                                                                                     | *Structure and Interpretation of Computer Programs*           | Berkeley CS 61A von Brian Harvey    |
| **[Computerarchitektur](#computerarchitektur)**                         | Ohne solides mentales Modell dafÃ¼r, wie Computer tatsÃ¤chlich funktionieren, werden all deine hÃ¶here Abstraktionen brÃ¼chig sein.                                              | *Computer Systems: A Programmer's Perspective*                | Berkeley CS 61C                     |
| **[Algorithmen und Datenstrukturen](#algorithmen-und-datenstrukturen)** | Wenn du nicht weiÃŸt, wie du allgegenwÃ¤rtige Datenstrukturen wie Stapel, Warteschlangen, BÃ¤ume und Graphen verwenden sollst, wirst du schwierige Probleme nicht lÃ¶sen kÃ¶nnen. | *The Algorithm Design Manual*                                 | Vorlesungen von Steven Skiena       |
| **[Mathematik fÃ¼r Informatik](#mathematik-fuer-informatik)**            | Informatik ist im Grunde ein Zweig der angewandten Mathematik, also wir dir das Mathe lernen einen Wettbewerbsvorteil verschaffen.                                           | *Mathematics for Computer Science*                            | MIT 6.042J von Tom Leighton         |
| **[Betriebssysteme](#betriebssysteme)**                                 | Der GroÃŸteil von Code, den du schreibst, wird vom einem Betriebssystem ausgefÃ¼hrt. Du solltest also wissen, wie diese Systeme zusammenwirken.                                | *Operating Systems: Three Easy Pieces*                        | Berkeley CS 162                     |
| **[Computernetzwerke](#computernetzwerke)**                             | Das Internet stellte sich als groÃŸe Sache heraus. Lerne, wie es funktioniert, um sein volles Potenzial zu erschlieÃŸen.                                                       | *Computer Networking: A Top-Down Approach*                    | Stanford CS 144                     |
| **[Datenbanken](#datenbanken)**                                         | Daten sind das HerzstÃ¼ck vieler wichtigen Anwendungen, aber nur wenige verstehen, wie Datenbanksysteme wirklich funktionieren.                                               | *Readings in Database Systems*                                | Berkeley CS 186 von Joe Hellerstein |
| **[Verteilte Systeme](#verteilte-systeme)**                             | Heutzutage bestehen die *meisten* Systeme aus verteilten Systemen.                                                                                                           | *Designing Data-Intensive Applications* von Martin Kleppmann  | MIT 6.824                           |

## Immer noch zu viel?

Ist die Vorstellung zu Ã¼berwÃ¤ltigend, 9 Themen Ã¼ber mehrere Jahre selber durcharbeiten zu mÃ¼ssen, empfehlen wir, du fokussierst dich nur auf zwei BÃ¼cher: *Computer Systems: A Programmer's Perspective* und *Designing Data Intensive Applications*. ErfahrungsgemÃ¤ÃŸ bieten diese zwei BÃ¼cher eine unglaublich hohe Rendite auf die investierte Zeit, insbesondere fÃ¼r autodidaktische Ingenieur/innen und Bootcamp Absolvent/innen, die an vernetzten Anwendungen arbeiten. Sie kÃ¶nnen auch eine "Einstiegsdroge" fÃ¼r die weiteren oben aufgelisteten Themen dienen.

## Warum Informatik lernen?

Es gibt zwei Arten von Softwareingenieur/innen: Die einen, die Informatik ausreichend gut verstehen, um anspruchsvolle, innovative Arbeit zu leisten, und die anderen, die nur Ã¼ber die Runden kommen, weil sie mit einigen high-level Tools vertraut sind.

Beide nennen sich Softwareingenieur/in, und beide verdienen Ã¤hnlich viel in den frÃ¼hes Berufsjahren. Aber Ingenieur/innen der 1. Art entwickeln sich mit der Zeit zu erfÃ¼llenderen und besser vergÃ¼teten Arbeit, sei es wertvolle kommerzielle Arbeit, bahnbrechende Open-Source Projekte, technische FÃ¼hrung oder hochwertige individuelle BeitrÃ¤ge.

Ingenieur/innen der 1. Art finden Wege, um Informatik tiefer zu erlernen, sei es mit konventionellen Mitteln oder durch unermÃ¼dliches Lernen im Laufe der Karriere. Ingenieur/innen der 2. Art bleiben typischerweise an der OberflÃ¤che, lernen bestimmte Tools und Technologien anstatt deren Grundlagen, und eignen sich nur dann neue FÃ¤higkeiten an, wenn die Winde technologischer Trends sich drehen.

Zur Zeit steigt die Anzahl der Berufseinsteiger in der Branche rasch an, wÃ¤hrend die Anzahl an Informatikabsolvent/innen relativ stabil bleibt. Dieses Ãœberangebot an Ingenieur/innen der 2. Art reduziert inzwischen ihre Berufschancen und hÃ¤lt sie von der erfÃ¼llenderen Arbeit in der Branche fern. Egal ob du anstrebst, ein/e Ingenieur/in der 1. Art zu werden, oder mehr Jobsicherheit suchst: Informatik zu lernen ist der einzige zuverlÃ¤ssige Weg.

## LeitfÃ¤den der Themen

### Programmierung

Die meisten GrundstudiengÃ¤nge in der Informatik beginnen mit einer "EinfÃ¼hrung" in die Computerprogrammierung. Die besten Versionen dieser Kurse richten sich nicht nur an AnfÃ¤nger, sondern auch an diejenigen, die nÃ¼tzliche Konzepte und Programmiermodelle beim ersten Erlernen des Programmierens verpasst haben.

Unsere Standardempfehlung fÃ¼r diesen Inhalt ist der Klassiker *Structure and Interpretation of Computer Programs*, der online kostenlos als [Buch](https://sarabander.github.io/sicp/html/index.xhtml) und als Reihe von [Videovorlesungen am MIT](https://sarabander.github.io/sicp/html/index.xhtml) verfÃ¼gbar ist. Obwohl diese Vorlesungen hervorragend sind, empfehlen wir als Videovorlesung stattdessen die [SICP Vorlesungen von Brian Harvey](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter) (vom Kurs 61A in Berkeley). Diese sind ausgefeilter und besser fÃ¼r neue Studierende geeignet als die MIT-Vorlesungen.

Wir empfehlen, wenigstens die ersten drei Kapitel von SICP und die Ãœbungsaufgaben durchzuarbeiten. Als zusÃ¤tzliche Ãœbung, bearbeite eine Reihe von kleinen Programmieraufgaben, z.B. die Aufgaben auf [exercism](https://exercism.org/).

Seit dieser Leitfaden in 2016 zuerst verÃ¶ffentlicht wurde, war eine der meist gestellten Fragen ob wir inzwischen eine aktuellere Aufzeichnung von Kurs 61A von John DeNero, oder das entsprechende Lehrbuch [Composing Programs](https://composingprograms.com/) empfehlen wÃ¼rden, das in der "Tradition von SICP" steht, aber Python verwendet. Wir sind der Meinung, diese Ressourcen von DeNero sind auch groÃŸartig, und manche Studierende werden diese bevorzugen, aber wir schlagen trotzdem vor, SICP, Scheme und Brian Harveys Vorlesungen als erste Ressourcen auszuprobieren.

Weshalb? Weil SICP einzigartig in seiner FÃ¤higkeit ist, zumindest potenziell deine grundlegenden Ãœberzeugungen Ã¼ber Computern und Programmierung zu verÃ¤ndern. Nicht alle werden diese Erfahrung machen. Manche werden das Buch hassen, andere schaffen es nicht weiter als die ersten paar Seiten. Aber der potentielle Gewinn macht es einen Versuch wert.

Wenn du an SICP keinen SpaÃŸ findest, versuche es mit *Composing Programs*. Wenn dir das immer noch nicht zusagt, probiere [How to Design Programs](http://htdp.org/) aus. Wenn sich deine BemÃ¼hungen trotzdem nicht lohnen, ist es vielleicht ein Zeichen dafÃ¼r, dass du dich zunÃ¤chst auf andere Themen konzentrieren und in 1-2 Jahren wieder auf das Disziplin der Programmierung zurÃ¼ckkommen solltest.

AbschlieÃŸend eine Klarstellung: Dieser Leitfaden ist NICHT fÃ¼r absolute ProgrammieranfÃ¤nger ausgelegt. Wir nehmen an, du bist bereits kompetent im Programmieren ohne Informatikhintergrund, und mÃ¶chtest WissenslÃ¼cken schlieÃŸen. Die Tatsache, dass wir einen Abschnitt Ã¼ber Programmierung eingefÃ¼gt haben, ist lediglich eine Erinnerung daran, dass es noch mehr zu lernen geben kann. FÃ¼r diejenigen, die noch nie programmiert haben, es aber gern tun wÃ¼rden, wÃ¤re vielleicht [dieser Leitfaden](https://www.reddit.com/r/learnprogramming/wiki/faq/#wiki_getting_started) der richtige.

### Computerarchitektur

Computerarchitektur - manchmal auch "Computersysteme" oder "Computerorganisation" genannt - ist ein wichtiger erster Einblick in die Computertechnik unterhalb der OberflÃ¤che von Software. ErfahrungsgemÃ¤ÃŸ ist es das meist vernachlÃ¤ssigte Thema unter den autodidaktischen Ingenieur/innen.

Unser Lieblingsbuch zur EinfÃ¼hrung ist [Computer Systems: A Programmer's Perspective](http://csapp.cs.cmu.edu/3e/home.html), und ein typischer EinfÃ¼hrungskurs in die Computerarchitektur, der auf dieses Buch stÃ¼tzt, wÃ¼rde das meiste aus Kapiteln 1-6 [abdecken](http://csapp.cs.cmu.edu/3e/courses.html).

Wir lieben CS:APP fÃ¼r seinen praktischen, Programmierer-orientierten Ansatz. Obwohl das Buch weit nicht alles Ã¼ber Computerarchitektur abdeckt, ist es ein toller Ausgangspunkt fÃ¼r diejenigen, die in erster Linie Computersysteme verstehen wollen, um schnellere, effizientere und zuverlÃ¤ssigere Software zu schreiben.

FÃ¼r die, die eine sanftere EinfÃ¼hrung in das Thema und ein Gleichgewicht zwischen Hardware- und Softwarefragen bevorzugen, schlagen wir "_The Elements of Computing Systems_" vor, auch bekannt als "Nand2Tetris". Dies ist ein ehrgeiziges Werk, das versucht, ein zusammenhÃ¤ngendes VerstÃ¤ndnis zu vermitteln, wie alles in einem Computer funktioniert. Jedes Kapitel beschÃ¤ftigt sich mit dem Aufbau eines Teils vom System, vom Schreiben elementarer Logikgatter in HDL, Ã¼ber CPU und Assembler bis hin zu einer Anwendung in der GrÃ¶ÃŸe eines Tetris-Spiels.

Wir empfehlen, die ersten sechs Kapitel des Buches und die zugehÃ¶rigen Projekte durchzuarbeiten. Dies wir dein VerstÃ¤ndnis Ã¼ber den Zusammenhang der Maschinenarchitektur und der darauf laufenden Software weiterentwickeln.

Die erste HÃ¤lfte des Buches (und alle dazugehÃ¶rigen Projekte) sind kostenlos auf der [Nand2Tetris Webseite](https://www.nand2tetris.org/) verfÃ¼gbar. Es ist ebenso als [Coursera-Kurs mit begleitenden Videos](https://www.coursera.org/learn/build-a-computer) vorhanden.

Das Bestreben nach Einfachheit und KohÃ¤renz von Nand2Tetris geht auf Kosten der Tiefe. Insbesondere fehlen zwei sehr wichtige Konzepte der modernen Computerarchitektur, nÃ¤mlich Pipelining und Speicherhierarchie, weitgehend in diesem Text.

Sobald du dich mit dem Inhalt von Nand2Tetris vertraut gemacht hast, empfehlen wir, entweder zu CS:APP zurÃ¼ckzukehren, oder ["Computer Organizsation and Design"](https://www.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269?pldnSite=1) von Patterson und Hennessy in ErwÃ¤gung zu ziehen, ein ausgezeichnetes und mittlerweile klassisches Buch. Nicht jeder Abschnitt vom Buch ist essenziell, wir schlagen vor, [Kurs CS61C](https://inst.eecs.berkeley.edu/~cs61c/sp15/) "Great Ideas in Computer Architecture" von Berkeley fÃ¼r ausgewÃ¤hlte LektÃ¼ren zu verfolgen. Die Vorlesungsskripten und Ãœbungen sind online verfÃ¼gbar, und die vergangenen Vorlesungen befinden sich [auf dem Internet Archive](https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_).

> Hardware ist die Plattform.

_â€“ Mike Acton, Engine Direktor von Insomniac Games_

([Siehe seinen CppCon Vortrag an](https://www.youtube.com/watch?v=rX0ItVEVjHc))

### Algorithmen und Datenstrukturen

Wir sind uns mit jahrzehntelanger Weisheit einig, dass Vertrautheit mit gÃ¤ngigen Algorithmen und Datenstrukturen eine der meist ermÃ¤chtigenden Aspekte der Informatikausbildung darstellt. Dies ist auch eine groÃŸartige Stelle, die eigene ProblemlÃ¶sungsfÃ¤higkeit zu trainieren, die sich in allen anderen Studienbereichen auszahlen wird.

Es sind Hunderte von BÃ¼chern vorhanden, aber unser Favorit ist [The Algorithm Design Manual](https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/?pldnSite=1) von Steven Skiena. Er liebt offensichtlich das algorithmische LÃ¶sen von Problemen und schafft es typischerweise, Ã¤hnliche Begeisterung bei seinen Studierenden und Leser/innen zu wecken. Unserer Meinung nach sind die zwei hÃ¤ufiger Empfohlenen Texte (CLRS und Sedgewick) tendenziell zu beweislastig fÃ¼r diejenigen, die den Stoff vorwiegend als Hilfe bei der praktischen ProblemlÃ¶sung lernen.

FÃ¼r die, die Videovorlesungen bevorzugen, hat [Skiena groÃŸzÃ¼gigerweise seine online gestellt](https://www3.cs.stonybrook.edu/~skiena/373/videos/). Wir mÃ¶gen auch Tim Roughgardens Kurs sehr, verfÃ¼gbar [auf Coursera](https://www.coursera.org/specializations/algorithms) und [anderswo](http://timroughgarden.org/videos.html). Ob du den Vorlesungsstil von Skiena oder Roughgarden bevorzugst ist eine Frage der persÃ¶nlichen PrÃ¤ferenz. In der Tat gibt es Dutzende von guten Alternativen. Wenn du also eine findest, die dir gefÃ¤llt, empfehlen wir, bei dieser zu bleiben!

Zur Ãœbung bevorzugen wir, dass Studierende Aufgaben auf [Leetcode](https://leetcode.com/) lÃ¶sen. Diese sind tendenziell interessante Probleme mit ordentlichen begleitenden LÃ¶sungen und Diskussionen. Sie helfen auch, deinen Fortschritt anhand von Fragen zu messen, die hÃ¤ufig in technischen Interviews bei kompetitiven Softwareunternehmen gestellt werden. Wir empfehlen, etwa 100 beliebige leetcode Aufgaben im Rahmen des Studiums zu lÃ¶sen.

AbschlieÃŸend empfehlen wir [How to Solve it](https://www.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/?pldnSite=1) als hervorragenden und einzigartigen Leitfaden fÃ¼r die allgemeine ProblemlÃ¶sung, der fÃ¼r die Informatik ebenso anwendbar ist wir fÃ¼r die Mathematik.



> Ich habe nur eine Methode, die ich ausgiebig empfehle -- Denke nach bevor du schreibst.

_â€” Richard Hamming_

### Mathematik fÃ¼r Informatik

(In Bearbeitung)
